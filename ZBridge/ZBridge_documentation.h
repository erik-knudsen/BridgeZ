/* Erik Aagaard Knudsen.
 Copyright Â© 20013 - All Rights Reserved

 Project: ZBridge
 File: ZBridge_documentation.h
 Developers: eak

 Revision History:
 13-feb-2013 eak: Original

 Abstract: Documentation.

 Platforms: Qt.
 */

/**
 * @file
 * Documentation of ZBridge application.
 */

/** @mainpage
 *
 * @section intro_sec Introduction
 * The ZBridge application is a program for bridge players who want to play bridge
 * on a computer.\n
 * This documentation documents the software.
 *
 * @section design_sec Software Design
 * The design is centered around a few important objects.\n
 *
 * Most of the objects are singletons.
 *
 * @image html SoftwareDesign_Overview.jpg "Overview of software design"
 *\n\n\n
 *
 * The application structure follows the usual Qt application structure.\n\n
 *
 * The application is started by the CZBridgeApp object. This object owns the CZBridgeDoc
 * object, which holds most of the data for the application (mostly configuration data).
 * The CZBridgeApp also owns the CMainFrame object, which controls the main menu and user
 * interaction with the main menu.\n\n
 *
 * The CMainFrame object instantiates the CTblMngr controller and the CPlayView view.\n
 * The CPlayView shows the bridge table, user interaction with the table and other in-
 * formation related to the bridge play.\n\n
 *
 * The CTblMngr (instantiated as either CTblMngrServer or CTblMngrClient) controls the
 * user interaction with the bridge table. In the server (or standalone) role it controls
 * the 4 actors (bridge players). They can be either local or on a remote client. In the
 * client role it controls one local (on the client) actor.\n\n
 *
 * Communication with remote actors (bridge players) goes through CRemoteActorServer for
 * the server and CRemoteActorClient for the client.\n\n
 *
 * Local actors are implemented based on a state and action table generated by Yakindu.
 * The server is implemented based on another state and action table generated by
 * Yakindu.\n\n
 *
 * Actors can be either manual or automatic.\n
 * Manual actors are controlled by a user i.e. the user bids and plays the cards.\n
 * Automatic actors are controlled by the computer i.e. the computer bids and plays
 * the cards.\n\n
 *
 * The Qt signal/slot mechanism is used extensively. The Qt event mechanism is used
 * instead in a few places, where it seemed more natural.\n
 * Communication from table manager to actors and to playview is by means of direct
 * method calls. Communication from actors and playview to table manager is by means
 * of signals.
 */


/** @page exceptions Exceptions and asserts
 * There are a number of different ways to handle software failures. The way it is done
 * here utilize the c++ way. Exceptions can be caught in methods as
 * prescribed by the throw signature of the method, in which case they are handled
 * by the unexpected handler. Or they can propagate to the top level of the call stack,
 * in which case they are handled by the terminate handler. Resources are cleaned up
 * until the point where the unexpected handler or the terminate handler takes over.\n\n
 *
 * We distinguish in here between two types of software failures:\n
 *   - Non recoverable failures.\n
 *
 *     - Asserts are used for failures determined to be discovered during debugging.
 *       For some failures there is no doubt that they must be discovered during
 *       debugging. Others are not quite so straightforward e.g. here the lack of some of
 *       the operating system resources are considered to be a
 *       failure to be found during debugging.\n
 *       Asserts are turned off in the release version of the application, since they
 *       are assumed found in the debugging of the application.\n\n
 *
 *     - Exceptions are used for failures that initially are considered recoverable
 *       but later in the processing change status to non recoverable. These exceptions
 *       are finally caught by either the unexpected handler or the terminate handler.\n\n
 *
 *   - Recoverable failures.\n
 *
 *     - Exceptions are used for recoverable failures. Recoverable failures are not always
 *       true failures, but just exceptions which can (and should be) be handled. At the
 *       point where they are initiated it is left to the embracing activator to determine
 *       the type of failure.\n
 *       As an example here, failure in the allocation of memory starts as a
 *       recoverable failure, but is immediately considered a non recoverable failure (i.e.
 *       it is finally caught by either the unexpected handler or the terminate handler.\n
 *
 *
 * It is left to the (default) exit handler to close down the application in case of a non
 * recoverable exception.\n\n
 *
 * The application defines its own exception base class ZBridgeException, which is derived from the
 * c++ runtime_error exception. Some ZBridgeExceptions are recoverable and some are not. Other
 * exceptions in addition to ZBridgeException are considered non recoverable.\n\n
 *
 * Currently there are the following exceptions derived from ZBridgeExceptions:\n
 *
 *   - FatalException These are exceptions considered non recoverable errors.
 *   - NetProtocolException These are exceptions thrown while handling the net
 *     communication. They are considered non fatal and are just shown to the user..
 *   - PlayException These are exceptions thrown while handling the play of cards.
 *     They are considered non fatal and are just shown to the user.
 *
 * Memory allocation errors are considered fatal errors and activates immediately (unless
 * otherwise specified) the unexpected handler. This is not explicitly mentioned in the
 * documentation of the affected methods.
 *
 * I know there is some dispute about the value of c++ exceptions. I have tried to use them
 * in this application in a coherent way and in a way I find useful.\n
 * I use throw specifications for methods to let the unexpected handler catch exceptions as
 * soon as they are found non recoverable. The only real problem with that as far as I can
 * see is how to tell the user. Debugging is easy enough though and I probably won't be able to
 * tell the user anyway in these situations.
 */
